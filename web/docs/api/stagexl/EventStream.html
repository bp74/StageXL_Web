        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>EventStream&lt;T&gt; class / stagexl Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="stagexl" data-type="EventStream&amp;lt;T&amp;gt;">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../stagexl.html">stagexl</a> &rsaquo; <a href="../stagexl/EventStream.html">EventStream&lt;T&gt;</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../metadata.html">metadata</a></h2><h2><div class="icon-library"></div><a href="../stagexl.html">stagexl</a></h2><ul class="icon">
<li><a href="../stagexl/AlphaMaskFilter.html"><div class="icon-class"></div>AlphaMaskFilter</a></li>
<li><a href="../stagexl/Animatable.html"><div class="icon-class"></div>Animatable</a></li>
<li><a href="../stagexl/AnimationChain.html"><div class="icon-class"></div>AnimationChain</a></li>
<li><a href="../stagexl/AnimationGroup.html"><div class="icon-class"></div>AnimationGroup</a></li>
<li><a href="../stagexl/AudioElementMixer.html"><div class="icon-class"></div>AudioElementMixer</a></li>
<li><a href="../stagexl/AudioElementSound.html"><div class="icon-class"></div>AudioElementSound</a></li>
<li><a href="../stagexl/AudioElementSoundChannel.html"><div class="icon-class"></div>AudioElementSoundChannel</a></li>
<li><a href="../stagexl/Bitmap.html"><div class="icon-class"></div>Bitmap</a></li>
<li><a href="../stagexl/BitmapData.html"><div class="icon-class"></div>BitmapData</a></li>
<li><a href="../stagexl/BitmapDataLoadOptions.html"><div class="icon-class"></div>BitmapDataLoadOptions</a></li>
<li><a href="../stagexl/BitmapDrawable.html"><div class="icon-class"></div>BitmapDrawable</a></li>
<li><a href="../stagexl/BitmapFilter.html"><div class="icon-class"></div>BitmapFilter</a></li>
<li><a href="../stagexl/BlurFilter.html"><div class="icon-class"></div>BlurFilter</a></li>
<li><a href="../stagexl/BroadcastEvent.html"><div class="icon-class"></div>BroadcastEvent</a></li>
<li><a href="../stagexl/ButtonHelper.html"><div class="icon-class"></div>ButtonHelper</a></li>
<li><a href="../stagexl/CapsStyle.html"><div class="icon-class"></div>CapsStyle</a></li>
<li><a href="../stagexl/ChangeHandler.html"><div class="icon-interface"></div>ChangeHandler</a></li>
<li><a href="../stagexl/Circle.html"><div class="icon-class"></div>Circle</a></li>
<li><a href="../stagexl/Color.html"><div class="icon-class"></div>Color</a></li>
<li><a href="../stagexl/ColorMatrixFilter.html"><div class="icon-class"></div>ColorMatrixFilter</a></li>
<li><a href="../stagexl/ColorTransform.html"><div class="icon-class"></div>ColorTransform</a></li>
<li><a href="../stagexl/CompositeOperation.html"><div class="icon-class"></div>CompositeOperation</a></li>
<li><a href="../stagexl/DelayedCall.html"><div class="icon-class"></div>DelayedCall</a></li>
<li><a href="../stagexl/DisplayObject.html"><div class="icon-class"></div>DisplayObject</a></li>
<li><a href="../stagexl/DisplayObjectContainer.html"><div class="icon-class"></div>DisplayObjectContainer</a></li>
<li><a href="../stagexl/DropShadowFilter.html"><div class="icon-class"></div>DropShadowFilter</a></li>
<li><a href="../stagexl/EaseFunction.html"><div class="icon-interface"></div>EaseFunction</a></li>
<li><a href="../stagexl/EnterFrameEvent.html"><div class="icon-class"></div>EnterFrameEvent</a></li>
<li><a href="../stagexl/Event.html"><div class="icon-class"></div>Event</a></li>
<li><a href="../stagexl/EventDispatcher.html"><div class="icon-class"></div>EventDispatcher</a></li>
<li><a href="../stagexl/EventListener.html"><div class="icon-interface"></div>EventListener&lt;T&gt;</a></li>
<li><a href="../stagexl/EventPhase.html"><div class="icon-class"></div>EventPhase</a></li>
<li><div class="icon-class"></div><strong>EventStream&lt;T&gt;</strong></li>
<li><a href="../stagexl/EventStreamProvider.html"><div class="icon-class"></div>EventStreamProvider&lt;T&gt;</a></li>
<li><a href="../stagexl/EventStreamSubscription.html"><div class="icon-class"></div>EventStreamSubscription&lt;T&gt;</a></li>
<li><a href="../stagexl/ExitFrameEvent.html"><div class="icon-class"></div>ExitFrameEvent</a></li>
<li><a href="../stagexl/FlipBook.html"><div class="icon-class"></div>FlipBook</a></li>
<li><a href="../stagexl/Gauge.html"><div class="icon-class"></div>Gauge</a></li>
<li><a href="../stagexl/GlassPlate.html"><div class="icon-class"></div>GlassPlate</a></li>
<li><a href="../stagexl/GlowFilter.html"><div class="icon-class"></div>GlowFilter</a></li>
<li><a href="../stagexl/Graphics.html"><div class="icon-class"></div>Graphics</a></li>
<li><a href="../stagexl/GraphicsGradient.html"><div class="icon-class"></div>GraphicsGradient</a></li>
<li><a href="../stagexl/GraphicsPattern.html"><div class="icon-class"></div>GraphicsPattern</a></li>
<li><a href="../stagexl/HtmlObject.html"><div class="icon-class"></div>HtmlObject</a></li>
<li><a href="../stagexl/InteractiveObject.html"><div class="icon-class"></div>InteractiveObject</a></li>
<li><a href="../stagexl/JointStyle.html"><div class="icon-class"></div>JointStyle</a></li>
<li><a href="../stagexl/Juggler.html"><div class="icon-class"></div>Juggler</a></li>
<li><a href="../stagexl/KeyboardEvent.html"><div class="icon-class"></div>KeyboardEvent</a></li>
<li><a href="../stagexl/KeyLocation.html"><div class="icon-class"></div>KeyLocation</a></li>
<li><a href="../stagexl/Mask.html"><div class="icon-class"></div>Mask</a></li>
<li><a href="../stagexl/Matrix.html"><div class="icon-class"></div>Matrix</a></li>
<li><a href="../stagexl/MockSound.html"><div class="icon-class"></div>MockSound</a></li>
<li><a href="../stagexl/MockSoundChannel.html"><div class="icon-class"></div>MockSoundChannel</a></li>
<li><a href="../stagexl/Mouse.html"><div class="icon-class"></div>Mouse</a></li>
<li><a href="../stagexl/MouseCursor.html"><div class="icon-class"></div>MouseCursor</a></li>
<li><a href="../stagexl/MouseEvent.html"><div class="icon-class"></div>MouseEvent</a></li>
<li><a href="../stagexl/MovieClip.html"><div class="icon-class"></div>MovieClip</a></li>
<li><a href="../stagexl/Multitouch.html"><div class="icon-class"></div>Multitouch</a></li>
<li><a href="../stagexl/MultitouchInputMode.html"><div class="icon-class"></div>MultitouchInputMode</a></li>
<li><a href="../stagexl/ObjectPool.html"><div class="icon-class"></div>ObjectPool&lt;T&gt;</a></li>
<li><a href="../stagexl/PixelSnapping.html"><div class="icon-class"></div>PixelSnapping</a></li>
<li><a href="../stagexl/Point.html"><div class="icon-class"></div>Point</a></li>
<li><a href="../stagexl/Rectangle.html"><div class="icon-class"></div>Rectangle</a></li>
<li><a href="../stagexl/RenderEvent.html"><div class="icon-class"></div>RenderEvent</a></li>
<li><a href="../stagexl/RenderLoop.html"><div class="icon-class"></div>RenderLoop</a></li>
<li><a href="../stagexl/RenderState.html"><div class="icon-class"></div>RenderState</a></li>
<li><a href="../stagexl/ResourceManager.html"><div class="icon-class"></div>ResourceManager</a></li>
<li><a href="../stagexl/ResourceManagerResource.html"><div class="icon-class"></div>ResourceManagerResource</a></li>
<li><a href="../stagexl/Shadow.html"><div class="icon-class"></div>Shadow</a></li>
<li><a href="../stagexl/Shape.html"><div class="icon-class"></div>Shape</a></li>
<li><a href="../stagexl/SimpleButton.html"><div class="icon-class"></div>SimpleButton</a></li>
<li><a href="../stagexl/Sound.html"><div class="icon-class"></div>Sound</a></li>
<li><a href="../stagexl/SoundChannel.html"><div class="icon-class"></div>SoundChannel</a></li>
<li><a href="../stagexl/SoundLoadOptions.html"><div class="icon-class"></div>SoundLoadOptions</a></li>
<li><a href="../stagexl/SoundMixer.html"><div class="icon-class"></div>SoundMixer</a></li>
<li><a href="../stagexl/SoundTransform.html"><div class="icon-class"></div>SoundTransform</a></li>
<li><a href="../stagexl/Sprite.html"><div class="icon-class"></div>Sprite</a></li>
<li><a href="../stagexl/SpriteSheet.html"><div class="icon-class"></div>SpriteSheet</a></li>
<li><a href="../stagexl/Stage.html"><div class="icon-class"></div>Stage</a></li>
<li><a href="../stagexl/StageAlign.html"><div class="icon-class"></div>StageAlign</a></li>
<li><a href="../stagexl/StageRenderMode.html"><div class="icon-class"></div>StageRenderMode</a></li>
<li><a href="../stagexl/StageScaleMode.html"><div class="icon-class"></div>StageScaleMode</a></li>
<li><a href="../stagexl/TextEvent.html"><div class="icon-class"></div>TextEvent</a></li>
<li><a href="../stagexl/TextField.html"><div class="icon-class"></div>TextField</a></li>
<li><a href="../stagexl/TextFieldAutoSize.html"><div class="icon-class"></div>TextFieldAutoSize</a></li>
<li><a href="../stagexl/TextFieldType.html"><div class="icon-class"></div>TextFieldType</a></li>
<li><a href="../stagexl/TextFormat.html"><div class="icon-class"></div>TextFormat</a></li>
<li><a href="../stagexl/TextFormatAlign.html"><div class="icon-class"></div>TextFormatAlign</a></li>
<li><a href="../stagexl/TextLineMetrics.html"><div class="icon-class"></div>TextLineMetrics</a></li>
<li><a href="../stagexl/TextureAtlas.html"><div class="icon-class"></div>TextureAtlas</a></li>
<li><a href="../stagexl/TextureAtlasFormat.html"><div class="icon-class"></div>TextureAtlasFormat</a></li>
<li><a href="../stagexl/TextureAtlasFrame.html"><div class="icon-class"></div>TextureAtlasFrame</a></li>
<li><a href="../stagexl/TimeGauge.html"><div class="icon-class"></div>TimeGauge</a></li>
<li><a href="../stagexl/Timeline.html"><div class="icon-class"></div>Timeline</a></li>
<li><a href="../stagexl/TimelineAction.html"><div class="icon-class"></div>TimelineAction</a></li>
<li><a href="../stagexl/TimelineStep.html"><div class="icon-class"></div>TimelineStep</a></li>
<li><a href="../stagexl/TimelineTween.html"><div class="icon-class"></div>TimelineTween</a></li>
<li><a href="../stagexl/TouchEvent.html"><div class="icon-class"></div>TouchEvent</a></li>
<li><a href="../stagexl/Transition.html"><div class="icon-class"></div>Transition</a></li>
<li><a href="../stagexl/TransitionFunction.html"><div class="icon-class"></div>TransitionFunction</a></li>
<li><a href="../stagexl/Tween.html"><div class="icon-class"></div>Tween</a></li>
<li><a href="../stagexl/TweenProperty.html"><div class="icon-class"></div>TweenProperty</a></li>
<li><a href="../stagexl/TweenPropertyFactory.html"><div class="icon-class"></div>TweenPropertyFactory</a></li>
<li><a href="../stagexl/Vector.html"><div class="icon-class"></div>Vector</a></li>
<li><a href="../stagexl/Warp.html"><div class="icon-class"></div>Warp</a></li>
<li><a href="../stagexl/WebAudioApiMixer.html"><div class="icon-class"></div>WebAudioApiMixer</a></li>
<li><a href="../stagexl/WebAudioApiSound.html"><div class="icon-class"></div>WebAudioApiSound</a></li>
<li><a href="../stagexl/WebAudioApiSoundChannel.html"><div class="icon-class"></div>WebAudioApiSoundChannel</a></li>
</ul>
</div>
<div class="content">
        <h2><strong>EventStream&lt;T extends Event&gt;</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class EventStream&lt;T extends Event&gt; extends Stream&lt;T&gt; {

 final EventDispatcher _target;
 final String _eventType;

 // We store the subscriptions in a immutable fixed length list.
 // If subscriptions are added or canceled we create a new list.
 // This is safe and gives good performance in JavaScript.

 List&lt;EventStreamSubscription&gt; _subscriptions = new List(0);
 int _capturingSubscriptionCount = 0;

 EventStream._internal(this._target, this._eventType);

 //-----------------------------------------------------------------------------------------------

 bool get isBroadcast =&gt; true;

 Stream&lt;T&gt; asBroadcastStream({
   void onListen(StreamSubscription subscription),
   void onCancel(StreamSubscription subscription)}) =&gt; this;

 bool get hasSubscriptions =&gt; _subscriptions.length &gt; 0;

 EventDispatcher get target =&gt; _target;
 String get eventType =&gt; _eventType;

 //-----------------------------------------------------------------------------------------------

 EventStreamSubscription&lt;T&gt; listen(void onData(T event), { Function onError, void onDone(),
   bool cancelOnError: false, int priority: 0 }) {

   return _subscribe(onData, false, priority);
 }

 //-----------------------------------------------------------------------------------------------

 EventStreamSubscription&lt;T&gt; capture(void onData(T event), { int priority: 0 }) {

   return _subscribe(onData, true, priority);
 }

 //-----------------------------------------------------------------------------------------------

 void cancelSubscriptions() {

   var subscriptions = _subscriptions;

   for(int i = 0; i &lt; subscriptions.length; i++) {
     _cancelSubscription(subscriptions[i]);
   }
 }

 //-----------------------------------------------------------------------------------------------
 //-----------------------------------------------------------------------------------------------

 EventStreamSubscription&lt;T&gt; _subscribe(EventListener eventListener, bool captures, int priority) {

   var subscription = new EventStreamSubscription&lt;T&gt;._internal(
       this, eventListener, captures, priority);

   // Insert the new subscription according to its priority.

   var oldSubscriptions = _subscriptions;
   var newSubscriptions = new List(oldSubscriptions.length + 1);
   var index = newSubscriptions.length - 1;

   for(int o = 0, n = 0; o &lt; oldSubscriptions.length; o++) {
     var oldSubscription = oldSubscriptions[o];
     if (o == n &amp;&amp; oldSubscription.priority &lt; priority) index = n++;
     newSubscriptions[n++] = oldSubscription;
   }

   newSubscriptions[index] = subscription;
   _subscriptions = newSubscriptions;

   // Increment the capturing subscription counter
   // or optimization for broadcast events.

   if (captures) {
     _capturingSubscriptionCount += 1;
   } else {
     switch(_eventType) {
       case Event.ENTER_FRAME: _enterFrameSubscriptions.add(subscription); break;
       case Event.EXIT_FRAME: _exitFrameSubscriptions.add(subscription); break;
       case Event.RENDER: _renderSubscriptions.add(subscription); break;
     }
   }

   return subscription;
 }

 //-----------------------------------------------------------------------------------------------

 _unsubscribe(EventListener eventListener, bool captures) {

   var subscriptions = _subscriptions;

   for(int i = 0; i &lt; subscriptions.length; i++) {
     var subscription = subscriptions[i];
     if (subscription.eventListener == eventListener &amp;&amp; subscription.isCapturing == captures) {
       _cancelSubscription(subscription);
     }
   }
 }

 //-----------------------------------------------------------------------------------------------

 _cancelSubscription(EventStreamSubscription eventStreamSubscription) {

   eventStreamSubscription._canceled = true;

   var oldSubscriptions = _subscriptions;
   if (oldSubscriptions.length == 0) return;

   var newSubscriptions = new List(oldSubscriptions.length - 1);

   for(int o = 0, n = 0; o &lt; oldSubscriptions.length; o++) {
     var oldSubscription = oldSubscriptions[o];
     if (identical(oldSubscription, eventStreamSubscription)) continue;
     if (n &gt;= newSubscriptions.length) return;
     newSubscriptions[n++] = oldSubscription;
   }

   if (eventStreamSubscription.isCapturing) {
     _capturingSubscriptionCount -= 1;
   }

   _subscriptions = newSubscriptions;
 }

 //-----------------------------------------------------------------------------------------------

 bool _hasPropagationSubscriptions(Event event) {

   return event.captures &amp;&amp; _capturingSubscriptionCount &gt; 0 ||
          event.bubbles &amp;&amp; _subscriptions.length &gt; _capturingSubscriptionCount;
 }

 //-----------------------------------------------------------------------------------------------

 _dispatchEventInternal(T event, EventDispatcher target, int eventPhase)  {

   var subscriptions = _subscriptions;

   for(var i = 0; i &lt; subscriptions.length; i++) {
     var subscription = subscriptions[i];
     if (subscription.isCanceled || subscription.isPaused ||
         subscription.isCapturing != (eventPhase == EventPhase.CAPTURING_PHASE)) continue;

     event._target = target;
     event._currentTarget = _target;
     event._eventPhase = eventPhase;
     subscription.eventListener(event);

     if (event.stopsImmediatePropagation) return;
   }
 }

}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream&lt;T&gt;</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>EventStream&lt;T&gt;</strong></span></p>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="eventType">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>eventType</strong> <a class="anchor-link"
            href="#eventType"
            title="Permalink to EventStream&lt;T&gt;.eventType">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String get eventType =&gt; _eventType;
</pre>
</div>
</div>
<div class="field inherited"><h4 id="first">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt;         <strong>first</strong> <a class="anchor-link"
            href="#first"
            title="Permalink to EventStream&lt;T&gt;.first">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Returns the first element of the stream.</p>
<p>Stops listening to the stream after the first element has been received.</p>
<p>Internally the method cancels its subscription after the first element.
This means that single-subscription (non-broadcast) streams are closed
and cannot be reused after a call to this getter.</p>
<p>If an error event occurs before the first data event, the resulting future
is completed with that error.</p>
<p>If this stream is empty (a done event occurs before the first data event),
the resulting future completes with a <a class="crossref" href="http://api.dartlang.org/dart_core/StateError.html">StateError</a>.</p>
<p>Except for the type of the error, this method is equivalent to
<code>this.elementAt(0)</code>.</p>
<pre class="source">
Future&lt;T&gt; get first {
 _Future&lt;T&gt; future = new _Future&lt;T&gt;();
 StreamSubscription subscription;
 subscription = this.listen(
   (T value) {
     _cancelAndValue(subscription, future, value);
   },
   onError: future._completeError,
   onDone: () {
     future._completeError(new StateError("No elements"));
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="field"><h4 id="hasSubscriptions">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>hasSubscriptions</strong> <a class="anchor-link"
            href="#hasSubscriptions"
            title="Permalink to EventStream&lt;T&gt;.hasSubscriptions">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool get hasSubscriptions =&gt; _subscriptions.length &gt; 0;
</pre>
</div>
</div>
<div class="field"><h4 id="isBroadcast">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>isBroadcast</strong> <a class="anchor-link"
            href="#isBroadcast"
            title="Permalink to EventStream&lt;T&gt;.isBroadcast">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>Reports whether this stream is a broadcast stream.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; </div></div>
<pre class="source">
bool get isBroadcast =&gt; true;
</pre>
</div>
</div>
<div class="field inherited"><h4 id="isEmpty">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>&gt;         <strong>isEmpty</strong> <a class="anchor-link"
            href="#isEmpty"
            title="Permalink to EventStream&lt;T&gt;.isEmpty">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Reports whether this stream contains any elements.</p>
<p>Stops listening to the stream after the first element has been received.</p>
<p>Internally the method cancels its subscription after the first element.
This means that single-subscription (non-broadcast) streams are closed and
cannot be reused after a call to this getter.</p>
<pre class="source">
Future&lt;bool&gt; get isEmpty {
 _Future&lt;bool&gt; future = new _Future&lt;bool&gt;();
 StreamSubscription subscription;
 subscription = this.listen(
   (_) {
     _cancelAndValue(subscription, future, false);
   },
   onError: future._completeError,
   onDone: () {
     future._complete(true);
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="field inherited"><h4 id="last">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt;         <strong>last</strong> <a class="anchor-link"
            href="#last"
            title="Permalink to EventStream&lt;T&gt;.last">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Returns the last element of the stream.</p>
<p>If an error event occurs before the first data event, the resulting future
is completed with that error.</p>
<p>If this stream is empty (a done event occurs before the first data event),
the resulting future completes with a <a class="crossref" href="http://api.dartlang.org/dart_core/StateError.html">StateError</a>.</p>
<pre class="source">
Future&lt;T&gt; get last {
 _Future&lt;T&gt; future = new _Future&lt;T&gt;();
 T result = null;
 bool foundResult = false;
 StreamSubscription subscription;
 subscription = this.listen(
   (T value) {
     foundResult = true;
     result = value;
   },
   onError: future._completeError,
   onDone: () {
     if (foundResult) {
       future._complete(result);
       return;
     }
     future._completeError(new StateError("No elements"));
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="field inherited"><h4 id="length">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a>&gt;         <strong>length</strong> <a class="anchor-link"
            href="#length"
            title="Permalink to EventStream&lt;T&gt;.length">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Counts the elements in the stream. </p>
<pre class="source">
Future&lt;int&gt; get length {
 _Future&lt;int&gt; future = new _Future&lt;int&gt;();
 int count = 0;
 this.listen(
   (_) { count++; },
   onError: future._completeError,
   onDone: () {
     future._complete(count);
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="field inherited"><h4 id="single">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt;         <strong>single</strong> <a class="anchor-link"
            href="#single"
            title="Permalink to EventStream&lt;T&gt;.single">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Returns the single element.</p>
<p>If an error event occurs before or after the first data event, the
resulting future is completed with that error.</p>
<p>If <code>this</code> is empty or has more than one element throws a <a class="crossref" href="http://api.dartlang.org/dart_core/StateError.html">StateError</a>.</p>
<pre class="source">
Future&lt;T&gt; get single {
 _Future&lt;T&gt; future = new _Future&lt;T&gt;();
 T result = null;
 bool foundResult = false;
 StreamSubscription subscription;
 subscription = this.listen(
   (T value) {
     if (foundResult) {
       // This is the second element we get.
       Error error = new StateError("More than one element");
       _cancelAndError(subscription, future, error, null);
       return;
     }
     foundResult = true;
     result = value;
   },
   onError: future._completeError,
   onDone: () {
     if (foundResult) {
       future._complete(result);
       return;
     }
     future._completeError(new StateError("No elements"));
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="field"><h4 id="target">
<button class="show-code">Code</button>
final <a href="../stagexl/EventDispatcher.html">EventDispatcher</a>         <strong>target</strong> <a class="anchor-link"
            href="#target"
            title="Permalink to EventStream&lt;T&gt;.target">#</a>
        </h4>
        <div class="doc">
<pre class="source">
EventDispatcher get target =&gt; _target;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method inherited"><h4 id="any">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>&gt; <strong>any</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> test(<a href="../stagexl/EventStream.html">T</a> element)) <a class="anchor-link" href="#any"
              title="Permalink to EventStream&lt;T&gt;.any">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Checks whether 
<span class="param">test</span> accepts any element provided by this stream.</p>
<p>Completes the <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> when the answer is known.</p>
<p>If this stream reports an error, the <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> reports that error.</p>
<p>Stops listening to the stream after the first matching element has been
found.</p>
<p>Internally the method cancels its subscription after this element. This
means that single-subscription (non-broadcast) streams are closed and
cannot be reused after a call to this method.</p>
<pre class="source">
Future&lt;bool&gt; any(bool test(T element)) {
 _Future&lt;bool&gt; future = new _Future&lt;bool&gt;();
 StreamSubscription subscription;
 subscription = this.listen(
     (T element) {
       _runUserCode(
         () =&gt; test(element),
         (bool isMatch) {
           if (isMatch) {
             _cancelAndValue(subscription, future, true);
           }
         },
         _cancelAndErrorClosure(subscription, future)
       );
     },
     onError: future._completeError,
     onDone: () {
       future._complete(false);
     },
     cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="asBroadcastStream">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>asBroadcastStream</strong>({void onListen(<a href="http://api.dartlang.org/dart_async/StreamSubscription.html" ref="external">StreamSubscription</a> subscription), void onCancel(<a href="http://api.dartlang.org/dart_async/StreamSubscription.html" ref="external">StreamSubscription</a> subscription)}) <a class="anchor-link" href="#asBroadcastStream"
              title="Permalink to EventStream&lt;T&gt;.asBroadcastStream">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns a multi-subscription stream that produces the same events as this.</p>
<p>If this stream is already a broadcast stream, it is returned unmodified.</p>
<p>If this stream is single-subscription, return a new stream that allows
multiple subscribers. It will subscribe to this stream when its first
subscriber is added, and will stay subscribed until this stream ends,
or a callback cancels the subscription.</p>
<p>If 
<span class="param">onListen</span> is provided, it is called with a subscription-like object
that represents the underlying subscription to this stream. It is
possible to pause, resume or cancel the subscription during the call
to 
<span class="param">onListen</span>. It is not possible to change the event handlers, including
using <a class="crossref" href="http://api.dartlang.org/dart_async/StreamSubscription.html#asFuture">StreamSubscription.asFuture</a>.</p>
<p>If 
<span class="param">onCancel</span> is provided, it is called in a similar way to 
<span class="param">onListen</span>
when the returned stream stops having listener. If it later gets
a new listener, the 
<span class="param">onListen</span> function is called again.</p>
<p>Use the callbacks, for example, for pausing the underlying subscription
while having no subscribers to prevent losing events, or canceling the
subscription when there are no listeners.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; </div></div>
<pre class="source">
Stream&lt;T&gt; asBroadcastStream({
 void onListen(StreamSubscription subscription),
 void onCancel(StreamSubscription subscription)}) =&gt; this;
</pre>
</div>
</div>
<div class="method"><h4 id="cancelSubscriptions">
<button class="show-code">Code</button>
void <strong>cancelSubscriptions</strong>() <a class="anchor-link" href="#cancelSubscriptions"
              title="Permalink to EventStream&lt;T&gt;.cancelSubscriptions">#</a></h4>
<div class="doc">
<pre class="source">
void cancelSubscriptions() {

 var subscriptions = _subscriptions;

 for(int i = 0; i &lt; subscriptions.length; i++) {
   _cancelSubscription(subscriptions[i]);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="capture">
<button class="show-code">Code</button>
<a href="../stagexl/EventStreamSubscription.html">EventStreamSubscription</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>capture</strong>(void onData(<a href="../stagexl/EventStream.html">T</a> event), {<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> priority: 0}) <a class="anchor-link" href="#capture"
              title="Permalink to EventStream&lt;T&gt;.capture">#</a></h4>
<div class="doc">
<pre class="source">
EventStreamSubscription&lt;T&gt; capture(void onData(T event), { int priority: 0 }) {

 return _subscribe(onData, true, priority);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="contains">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>&gt; <strong>contains</strong>(<a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> needle) <a class="anchor-link" href="#contains"
              title="Permalink to EventStream&lt;T&gt;.contains">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Checks whether 
<span class="param">needle</span> occurs in the elements provided by this stream.</p>
<p>Completes the <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> when the answer is known.
If this stream reports an error, the <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> will report that error.</p>
<pre class="source">
Future&lt;bool&gt; contains(Object needle) {
 _Future&lt;bool&gt; future = new _Future&lt;bool&gt;();
 StreamSubscription subscription;
 subscription = this.listen(
     (T element) {
       _runUserCode(
         () =&gt; (element == needle),
         (bool isMatch) {
           if (isMatch) {
             _cancelAndValue(subscription, future, true);
           }
         },
         _cancelAndErrorClosure(subscription, future)
       );
     },
     onError: future._completeError,
     onDone: () {
       future._complete(false);
     },
     cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="distinct">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>distinct</strong>([<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> equals(<a href="../stagexl/EventStream.html">T</a> previous, <a href="../stagexl/EventStream.html">T</a> next)]) <a class="anchor-link" href="#distinct"
              title="Permalink to EventStream&lt;T&gt;.distinct">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Skips data events if they are equal to the previous data event.</p>
<p>The returned stream provides the same events as this stream, except
that it never provides two consequtive data events that are equal.</p>
<p>Equality is determined by the provided 
<span class="param">equals</span> method. If that is
omitted, the '==' operator on the last provided data element is used.</p>
<pre class="source">
Stream&lt;T&gt; distinct([bool equals(T previous, T next)]) {
 return new _DistinctStream(this, equals);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="drain">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>drain</strong>([futureValue]) <a class="anchor-link" href="#drain"
              title="Permalink to EventStream&lt;T&gt;.drain">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Discards all data on the stream, but signals when it's done or an error
occured.</p>
<p>When subscribing using <a class="crossref" href="http://api.dartlang.org/dart_async/Stream.html#drain">drain</a>, cancelOnError will be true. This means
that the future will complete with the first error on the stream and then
cancel the subscription.</p>
<p>In case of a <code>done</code> event the future completes with the given

<span class="param">futureValue</span>.</p>
<pre class="source">
Future drain([var futureValue]) =&gt; listen(null, cancelOnError: true)
   .asFuture(futureValue);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="elementAt">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>elementAt</strong>(<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> index) <a class="anchor-link" href="#elementAt"
              title="Permalink to EventStream&lt;T&gt;.elementAt">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Returns the value of the 
<span class="param">index</span>th data event of this stream.</p>
<p>Stops listening to the stream after the 
<span class="param">index</span>th data event has been
received.</p>
<p>Internally the method cancels its subscription after these elements. This
means that single-subscription (non-broadcast) streams are closed and
cannot be reused after a call to this method.</p>
<p>If an error event occurs before the value is found, the future completes
with this error.</p>
<p>If a done event occurs before the value is found, the future completes
with a <a class="crossref" href="http://api.dartlang.org/dart_core/RangeError.html">RangeError</a>.</p>
<pre class="source">
Future&lt;T&gt; elementAt(int index) {
 if (index is! int || index &lt; 0) throw new ArgumentError(index);
 _Future&lt;T&gt; future = new _Future&lt;T&gt;();
 StreamSubscription subscription;
 subscription = this.listen(
   (T value) {
     if (index == 0) {
       _cancelAndValue(subscription, future, value);
       return;
     }
     index -= 1;
   },
   onError: future._completeError,
   onDone: () {
     future._completeError(new RangeError.value(index));
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="every">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>&gt; <strong>every</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> test(<a href="../stagexl/EventStream.html">T</a> element)) <a class="anchor-link" href="#every"
              title="Permalink to EventStream&lt;T&gt;.every">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Checks whether 
<span class="param">test</span> accepts all elements provided by this stream.</p>
<p>Completes the <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> when the answer is known.
If this stream reports an error, the <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> will report that error.</p>
<pre class="source">
Future&lt;bool&gt; every(bool test(T element)) {
 _Future&lt;bool&gt; future = new _Future&lt;bool&gt;();
 StreamSubscription subscription;
 subscription = this.listen(
     (T element) {
       _runUserCode(
         () =&gt; test(element),
         (bool isMatch) {
           if (!isMatch) {
             _cancelAndValue(subscription, future, false);
           }
         },
         _cancelAndErrorClosure(subscription, future)
       );
     },
     onError: future._completeError,
     onDone: () {
       future._complete(true);
     },
     cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="expand">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> <strong>expand</strong>(<a href="http://api.dartlang.org/dart_core/Iterable.html" ref="external">Iterable</a> convert(<a href="../stagexl/EventStream.html">T</a> value)) <a class="anchor-link" href="#expand"
              title="Permalink to EventStream&lt;T&gt;.expand">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Creates a new stream from this stream that converts each element
into zero or more events.</p>
<p>Each incoming event is converted to an <a class="crossref" href="http://api.dartlang.org/dart_core/Iterable.html">Iterable</a> of new events,
and each of these new events are then sent by the returned stream
in order.</p>
<pre class="source">
Stream expand(Iterable convert(T value)) {
 return new _ExpandStream&lt;T, dynamic&gt;(this, convert);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="firstWhere">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;dynamic&gt; <strong>firstWhere</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> test(<a href="../stagexl/EventStream.html">T</a> element), {<a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> defaultValue()}) <a class="anchor-link" href="#firstWhere"
              title="Permalink to EventStream&lt;T&gt;.firstWhere">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Finds the first element of this stream matching 
<span class="param">test</span>.</p>
<p>Returns a future that is filled with the first element of this stream
that 
<span class="param">test</span> returns true for.</p>
<p>If no such element is found before this stream is done, and a

<span class="param">defaultValue</span> function is provided, the result of calling 
<span class="param">defaultValue</span>
becomes the value of the future.</p>
<p>Stops listening to the stream after the first matching element has been
received.</p>
<p>Internally the method cancels its subscription after the first element that
matches the predicate. This means that single-subscription (non-broadcast)
streams are closed and cannot be reused after a call to this method.</p>
<p>If an error occurs, or if this stream ends without finding a match and
with no 
<span class="param">defaultValue</span> function provided, the future will receive an
error.</p>
<pre class="source">
Future&lt;dynamic&gt; firstWhere(bool test(T element), {Object defaultValue()}) {
 _Future&lt;dynamic&gt; future = new _Future();
 StreamSubscription subscription;
 subscription = this.listen(
   (T value) {
     _runUserCode(
       () =&gt; test(value),
       (bool isMatch) {
         if (isMatch) {
           _cancelAndValue(subscription, future, value);
         }
       },
       _cancelAndErrorClosure(subscription, future)
     );
   },
   onError: future._completeError,
   onDone: () {
     if (defaultValue != null) {
       _runUserCode(defaultValue, future._complete, future._completeError);
       return;
     }
     future._completeError(new StateError("firstMatch ended without match"));
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="fold">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>fold</strong>(initialValue, combine(previous, <a href="../stagexl/EventStream.html">T</a> element)) <a class="anchor-link" href="#fold"
              title="Permalink to EventStream&lt;T&gt;.fold">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Reduces a sequence of values by repeatedly applying 
<span class="param">combine</span>. </p>
<pre class="source">
Future fold(var initialValue, combine(var previous, T element)) {
 _Future result = new _Future();
 var value = initialValue;
 StreamSubscription subscription;
 subscription = this.listen(
   (T element) {
     _runUserCode(
       () =&gt; combine(value, element),
       (newValue) { value = newValue; },
       _cancelAndErrorClosure(subscription, result)
     );
   },
   onError: (e, st) {
     result._completeError(e, st);
   },
   onDone: () {
     result._complete(value);
   },
   cancelOnError: true);
 return result;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="forEach">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>forEach</strong>(void action(<a href="../stagexl/EventStream.html">T</a> element)) <a class="anchor-link" href="#forEach"
              title="Permalink to EventStream&lt;T&gt;.forEach">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Executes 
<span class="param">action</span> on each data event of the stream.</p>
<p>Completes the returned <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> when all events of the stream
have been processed. Completes the future with an error if the
stream has an error event, or if 
<span class="param">action</span> throws.</p>
<pre class="source">
Future forEach(void action(T element)) {
 _Future future = new _Future();
 StreamSubscription subscription;
 subscription = this.listen(
     (T element) {
       _runUserCode(
         () =&gt; action(element),
         (_) {},
         _cancelAndErrorClosure(subscription, future)
       );
     },
     onError: future._completeError,
     onDone: () {
       future._complete(null);
     },
     cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="handleError">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>handleError</strong>(<a href="http://api.dartlang.org/dart_core/Function.html" ref="external">Function</a> onError, {<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> test(error)}) <a class="anchor-link" href="#handleError"
              title="Permalink to EventStream&lt;T&gt;.handleError">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Creates a wrapper Stream that intercepts some errors from this stream.</p>
<p>If this stream sends an error that matches 
<span class="param">test</span>, then it is intercepted
by the <code>handle</code> function.</p>
<p>The 
<span class="param">onError</span> callback must be of type <code>void onError(error)</code> or
<code>void onError(error, StackTrace stackTrace)</code>. Depending on the function
type the the stream either invokes 
<span class="param">onError</span> with or without a stack
trace. The stack trace argument might be <code>null</code> if the stream itself
received an error without stack trace.</p>
<p>An [AsyncError] [:e:] is matched by a test function if <code>test(e)</code> returns
true. If 
<span class="param">test</span> is omitted, every error is considered matching.</p>
<p>If the error is intercepted, the <code>handle</code> function can decide what to do
with it. It can throw if it wants to raise a new (or the same) error,
or simply return to make the stream forget the error.</p>
<p>If you need to transform an error into a data event, use the more generic
<a class="crossref" href="http://api.dartlang.org/dart_async/Stream.html#transform">Stream.transform</a> to handle the event by writing a data event to
the output sink</p>
<pre class="source">
Stream&lt;T&gt; handleError(Function onError, { bool test(error) }) {
 return new _HandleErrorStream&lt;T&gt;(this, onError, test);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="join">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>&gt; <strong>join</strong>([<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> separator = ""]) <a class="anchor-link" href="#join"
              title="Permalink to EventStream&lt;T&gt;.join">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Collects string of data events' string representations.</p>
<p>If 
<span class="param">separator</span> is provided, it is inserted between any two
elements.</p>
<p>Any error in the stream causes the future to complete with that
error. Otherwise it completes with the collected string when
the "done" event arrives.</p>
<pre class="source">
Future&lt;String&gt; join([String separator = ""]) {
 _Future&lt;String&gt; result = new _Future&lt;String&gt;();
 StringBuffer buffer = new StringBuffer();
 StreamSubscription subscription;
 bool first = true;
 subscription = this.listen(
   (T element) {
     if (!first) {
       buffer.write(separator);
     }
     first = false;
     try {
       buffer.write(element);
     } catch (e, s) {
       _cancelAndError(subscription, result, e, s);
     }
   },
   onError: (e) {
     result._completeError(e);
   },
   onDone: () {
     result._complete(buffer.toString());
   },
   cancelOnError: true);
 return result;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="lastWhere">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;dynamic&gt; <strong>lastWhere</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> test(<a href="../stagexl/EventStream.html">T</a> element), {<a href="http://api.dartlang.org/dart_core/Object.html" ref="external">Object</a> defaultValue()}) <a class="anchor-link" href="#lastWhere"
              title="Permalink to EventStream&lt;T&gt;.lastWhere">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Finds the last element in this stream matching 
<span class="param">test</span>.</p>
<p>As <a class="crossref" href="http://api.dartlang.org/dart_async/Stream.html#firstWhere">firstWhere</a>, except that the last matching element is found.
That means that the result cannot be provided before this stream
is done.</p>
<pre class="source">
Future&lt;dynamic&gt; lastWhere(bool test(T element), {Object defaultValue()}) {
 _Future&lt;dynamic&gt; future = new _Future();
 T result = null;
 bool foundResult = false;
 StreamSubscription subscription;
 subscription = this.listen(
   (T value) {
     _runUserCode(
       () =&gt; true == test(value),
       (bool isMatch) {
         if (isMatch) {
           foundResult = true;
           result = value;
         }
       },
       _cancelAndErrorClosure(subscription, future)
     );
   },
   onError: future._completeError,
   onDone: () {
     if (foundResult) {
       future._complete(result);
       return;
     }
     if (defaultValue != null) {
       _runUserCode(defaultValue, future._complete, future._completeError);
       return;
     }
     future._completeError(new StateError("lastMatch ended without match"));
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="listen">
<button class="show-code">Code</button>
<a href="../stagexl/EventStreamSubscription.html">EventStreamSubscription</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>listen</strong>(void onData(<a href="../stagexl/EventStream.html">T</a> event), {<a href="http://api.dartlang.org/dart_core/Function.html" ref="external">Function</a> onError, void onDone(), <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> cancelOnError: false, <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> priority: 0}) <a class="anchor-link" href="#listen"
              title="Permalink to EventStream&lt;T&gt;.listen">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Adds a subscription to this stream.</p>
<p>On each data event from this stream, the subscriber's 
<span class="param">onData</span> handler
is called. If 
<span class="param">onData</span> is null, nothing happens.</p>
<p>On errors from this stream, the 
<span class="param">onError</span> handler is given a
object describing the error.</p>
<p>The 
<span class="param">onError</span> callback must be of type <code>void onError(error)</code> or
<code>void onError(error, StackTrace stackTrace)</code>. If 
<span class="param">onError</span> accepts
two arguments it is called with the stack trace (which could be <code>null</code> if
the stream itself received an error without stack trace).
Otherwise it is called with just the error object.</p>
<p>If this stream closes, the 
<span class="param">onDone</span> handler is called.</p>
<p>If 
<span class="param">cancelOnError</span> is true, the subscription is ended when
the first error is reported. The default is false.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; </div></div>
<pre class="source">
EventStreamSubscription&lt;T&gt; listen(void onData(T event), { Function onError, void onDone(),
 bool cancelOnError: false, int priority: 0 }) {

 return _subscribe(onData, false, priority);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="map">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> <strong>map</strong>(convert(<a href="../stagexl/EventStream.html">T</a> event)) <a class="anchor-link" href="#map"
              title="Permalink to EventStream&lt;T&gt;.map">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Creates a new stream that converts each element of this stream
to a new value using the 
<span class="param">convert</span> function.</p>
<pre class="source">
Stream map(convert(T event)) {
 return new _MapStream&lt;T, dynamic&gt;(this, convert);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="pipe">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a> <strong>pipe</strong>(<a href="http://api.dartlang.org/dart_async/StreamConsumer.html" ref="external">StreamConsumer</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; streamConsumer) <a class="anchor-link" href="#pipe"
              title="Permalink to EventStream&lt;T&gt;.pipe">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Binds this stream as the input of the provided <a class="crossref" href="http://api.dartlang.org/dart_async/StreamConsumer.html">StreamConsumer</a>.</p>
<pre class="source">
Future pipe(StreamConsumer&lt;T&gt; streamConsumer) {
 return streamConsumer.addStream(this).then((_) =&gt; streamConsumer.close());
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="reduce">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>reduce</strong>(<a href="../stagexl/EventStream.html">T</a> combine(<a href="../stagexl/EventStream.html">T</a> previous, <a href="../stagexl/EventStream.html">T</a> element)) <a class="anchor-link" href="#reduce"
              title="Permalink to EventStream&lt;T&gt;.reduce">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Reduces a sequence of values by repeatedly applying 
<span class="param">combine</span>.</p>
<pre class="source">
Future&lt;T&gt; reduce(T combine(T previous, T element)) {
 _Future&lt;T&gt; result = new _Future&lt;T&gt;();
 bool seenFirst = false;
 T value;
 StreamSubscription subscription;
 subscription = this.listen(
   (T element) {
     if (seenFirst) {
       _runUserCode(() =&gt; combine(value, element),
                    (T newValue) { value = newValue; },
                    _cancelAndErrorClosure(subscription, result));
     } else {
       value = element;
       seenFirst = true;
     }
   },
   onError: result._completeError,
   onDone: () {
     if (!seenFirst) {
       result._completeError(new StateError("No elements"));
     } else {
       result._complete(value);
     }
   },
   cancelOnError: true
 );
 return result;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="singleWhere">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>singleWhere</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> test(<a href="../stagexl/EventStream.html">T</a> element)) <a class="anchor-link" href="#singleWhere"
              title="Permalink to EventStream&lt;T&gt;.singleWhere">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Finds the single element in this stream matching 
<span class="param">test</span>.</p>
<p>Like <code>lastMatch</code>, except that it is an error if more than one
matching element occurs in the stream.</p>
<pre class="source">
Future&lt;T&gt; singleWhere(bool test(T element)) {
 _Future&lt;T&gt; future = new _Future&lt;T&gt;();
 T result = null;
 bool foundResult = false;
 StreamSubscription subscription;
 subscription = this.listen(
   (T value) {
     _runUserCode(
       () =&gt; true == test(value),
       (bool isMatch) {
         if (isMatch) {
           if (foundResult) {
             _cancelAndError(
                 subscription,
                 future,
                 new StateError('Multiple matches for "single"'),
                 null);
             return;
           }
           foundResult = true;
           result = value;
         }
       },
       _cancelAndErrorClosure(subscription, future)
     );
   },
   onError: future._completeError,
   onDone: () {
     if (foundResult) {
       future._complete(result);
       return;
     }
     future._completeError(new StateError("single ended without match"));
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="skip">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>skip</strong>(<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> count) <a class="anchor-link" href="#skip"
              title="Permalink to EventStream&lt;T&gt;.skip">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Skips the first 
<span class="param">count</span> data events from this stream.</p>
<pre class="source">
Stream&lt;T&gt; skip(int count) {
 return new _SkipStream(this, count);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="skipWhile">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>skipWhile</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> test(<a href="../stagexl/EventStream.html">T</a> element)) <a class="anchor-link" href="#skipWhile"
              title="Permalink to EventStream&lt;T&gt;.skipWhile">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Skip data events from this stream while they are matched by 
<span class="param">test</span>.</p>
<p>Error and done events are provided by the returned stream unmodified.</p>
<p>Starting with the first data event where 
<span class="param">test</span> returns false for the
event data, the returned stream will have the same events as this stream.</p>
<pre class="source">
Stream&lt;T&gt; skipWhile(bool test(T element)) {
 return new _SkipWhileStream(this, test);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="take">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>take</strong>(<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> count) <a class="anchor-link" href="#take"
              title="Permalink to EventStream&lt;T&gt;.take">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Provides at most the first <code>n</code> values of this stream.</p>
<p>Forwards the first <code>n</code> data events of this stream, and all error
events, to the returned stream, and ends with a done event.</p>
<p>If this stream produces fewer than 
<span class="param">count</span> values before it's done,
so will the returned stream.</p>
<p>Stops listening to the stream after the first <code>n</code> elements have been
received.</p>
<p>Internally the method cancels its subscription after these elements. This
means that single-subscription (non-broadcast) streams are closed and
cannot be reused after a call to this method.</p>
<pre class="source">
Stream&lt;T&gt; take(int count) {
 return new _TakeStream(this, count);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="takeWhile">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>takeWhile</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> test(<a href="../stagexl/EventStream.html">T</a> element)) <a class="anchor-link" href="#takeWhile"
              title="Permalink to EventStream&lt;T&gt;.takeWhile">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Forwards data events while 
<span class="param">test</span> is successful.</p>
<p>The returned stream provides the same events as this stream as long
as 
<span class="param">test</span> returns <code>true</code> for the event data. The stream is done
when either this stream is done, or when this stream first provides
a value that 
<span class="param">test</span> doesn't accept.</p>
<p>Stops listening to the stream after the accepted elements.</p>
<p>Internally the method cancels its subscription after these elements. This
means that single-subscription (non-broadcast) streams are closed and
cannot be reused after a call to this method.</p>
<pre class="source">
Stream&lt;T&gt; takeWhile(bool test(T element)) {
 return new _TakeWhileStream(this, test);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="timeout">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> <strong>timeout</strong>(<a href="http://api.dartlang.org/dart_core/Duration.html" ref="external">Duration</a> timeLimit, {void onTimeout(<a href="http://api.dartlang.org/dart_async/EventSink.html" ref="external">EventSink</a> sink)}) <a class="anchor-link" href="#timeout"
              title="Permalink to EventStream&lt;T&gt;.timeout">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Creates a new stream with the same events as this stream.</p>
<p>Whenever more than 
<span class="param">timeLimit</span> passes between two events from this stream,
the 
<span class="param">onTimeout</span> function is called.</p>
<p>The countdown doesn't start until the returned stream is listened to.
The countdown is reset every time an event is forwarded from this stream,
or when the stream is paused and resumed.</p>
<p>The 
<span class="param">onTimeout</span> function is called with one argument: an
<a class="crossref" href="http://api.dartlang.org/dart_async/EventSink.html">EventSink</a> that allows putting events into the returned stream.
This <code>EventSink</code> is only valid during the call to <code>onTimeout</code>.</p>
<p>If <code>onTimeout</code> is omitted, a timeout will just put a <a class="crossref" href="http://api.dartlang.org/dart_async/TimeoutException.html">TimeoutException</a>
into the error channel of the returned stream.</p>
<pre class="source">
Stream timeout(Duration timeLimit, {void onTimeout(EventSink sink)}) {
 StreamSubscription&lt;T&gt; subscription;
 _StreamController controller;
 // The following variables are set on listen.
 Timer timer;
 Zone zone;
 Function timeout;

 void onData(T event) {
   timer.cancel();
   controller.add(event);
   timer = zone.createTimer(timeLimit, timeout);
 }
 void onError(error, StackTrace stackTrace) {
   timer.cancel();
   controller.addError(error, stackTrace);
   timer = zone.createTimer(timeLimit, timeout);
 }
 void onDone() {
   timer.cancel();
   controller.close();
 }
 controller = new _SyncStreamController(
     () {
       // This is the onListen callback for of controller.
       // It runs in the same zone that the subscription was created in.
       // Use that zone for creating timers and running the onTimeout
       // callback.
       zone = Zone.current;
       if (onTimeout == null) {
         timeout = () {
           controller.addError(new TimeoutException("No stream event",
                                                    timeLimit));
         };
       } else {
         onTimeout = zone.registerUnaryCallback(onTimeout);
         _ControllerEventSinkWrapper wrapper =
             new _ControllerEventSinkWrapper(null);
         timeout = () {
           wrapper._sink = controller;  // Only valid during call.
           zone.runUnaryGuarded(onTimeout, wrapper);
           wrapper._sink = null;
         };
       }

       subscription = this.listen(onData, onError: onError, onDone: onDone);
       timer = zone.createTimer(timeLimit, timeout);
     },
     () {
       timer.cancel();
       subscription.pause();
     },
     () {
       subscription.resume();
       timer = zone.createTimer(timeLimit, timeout);
     },
     () {
       timer.cancel();
       Future result = subscription.cancel();
       subscription = null;
       return result;
     });
 return controller.stream;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="toList">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt;&gt; <strong>toList</strong>() <a class="anchor-link" href="#toList"
              title="Permalink to EventStream&lt;T&gt;.toList">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Collects the data of this stream in a <a class="crossref" href="http://api.dartlang.org/dart_core/List.html">List</a>. </p>
<pre class="source">
Future&lt;List&lt;T&gt;&gt; toList() {
 List&lt;T&gt; result = &lt;T&gt;[];
 _Future&lt;List&lt;T&gt;&gt; future = new _Future&lt;List&lt;T&gt;&gt;();
 this.listen(
   (T data) {
     result.add(data);
   },
   onError: future._completeError,
   onDone: () {
     future._complete(result);
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="toSet">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html" ref="external">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/Set.html" ref="external">Set</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt;&gt; <strong>toSet</strong>() <a class="anchor-link" href="#toSet"
              title="Permalink to EventStream&lt;T&gt;.toSet">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Collects the data of this stream in a <a class="crossref" href="http://api.dartlang.org/dart_core/Set.html">Set</a>. </p>
<pre class="source">
Future&lt;Set&lt;T&gt;&gt; toSet() {
 Set&lt;T&gt; result = new Set&lt;T&gt;();
 _Future&lt;Set&lt;T&gt;&gt; future = new _Future&lt;Set&lt;T&gt;&gt;();
 this.listen(
   (T data) {
     result.add(data);
   },
   onError: future._completeError,
   onDone: () {
     future._complete(result);
   },
   cancelOnError: true);
 return future;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="transform">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> <strong>transform</strong>(<a href="http://api.dartlang.org/dart_async/StreamTransformer.html" ref="external">StreamTransformer</a>&lt;<a href="../stagexl/EventStream.html">T</a>, dynamic&gt; streamTransformer) <a class="anchor-link" href="#transform"
              title="Permalink to EventStream&lt;T&gt;.transform">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Chains this stream as the input of the provided <a class="crossref" href="http://api.dartlang.org/dart_async/StreamTransformer.html">StreamTransformer</a>.</p>
<p>Returns the result of <code>streamTransformer.bind</code> itself.</p>
<pre class="source">
Stream transform(StreamTransformer&lt;T, dynamic&gt; streamTransformer) {
 return streamTransformer.bind(this);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="where">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a>&lt;<a href="../stagexl/EventStream.html">T</a>&gt; <strong>where</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> test(<a href="../stagexl/EventStream.html">T</a> event)) <a class="anchor-link" href="#where"
              title="Permalink to EventStream&lt;T&gt;.where">#</a></h4>
<div class="inherited-from">inherited from <a href="http://api.dartlang.org/dart_async/Stream.html" ref="external">Stream</a> </div><div class="doc">
<p>Creates a new stream from this stream that discards some data events.</p>
<p>The new stream sends the same error and done events as this stream,
but it only sends the data events that satisfy the 
<span class="param">test</span>.</p>
<pre class="source">
Stream&lt;T&gt; where(bool test(T event)) {
 return new _WhereStream&lt;T&gt;(this, test);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-12-26 08:49:51.702</div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
